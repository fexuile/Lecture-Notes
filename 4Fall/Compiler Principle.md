# 前言
编译器 VS 解释器：
- 编译器是将源程序转换成可执行程序（先转换后执行）
- 解释器是在转换源程序的同时执行程序（边转换边执行）

编译器的组织结构：前端（从源程序到中间代码），后端（从中间代码到机器指令）
遍（Pass）：对源程序或者中间代码从头到尾扫描一次完成任务，这过程叫做pass。

# 词法分析
词法分析器：读入源程序，输出token序列（包括名字+类型）
token类别包括
- 保留字
- 标识符
- 字面常数
- 运算符
- 分解符

如何识别词法单元：
1. 状态转换图：**优先匹配长度最长的，长度相同的情况下匹配最先的**
2. LEX生成工具：lex源程序->C文件->可执行文件，匹配规则和状态转换图相同。

有限自动机：是识别器，只能对每个可能的输入串简单地回答 yes / no
DFA：确定的有限自动机，对于一个状态的一个输入只有可能有一个输出和后继状态。
NFA：不确定的有限自动机，对于一个状态一个输入应该是转移到状态的一个子集。NFA可以转移$\varepsilon$。
**DFA的表达能力与NFA是等价的，DFA是特殊的NFA**

从正则表达式到NFA：通过一个定式可以得到：
- |就走上下两条
- +就连在一起
- \*就采用一个循环的来表示
然后将正则表达式一一还原即可。

从NFA到DFA：通过子集构造法得到，每一步都走到$\varepsilon$闭包中。

DFA的化简：首先将集合分为终结态和非终结态，然后依次划分出与集合内转移不相同的，直到无法再划分。

Lex的做法：先将NFA合并，然后变成DFA化简，确定终结态。
> 注意：
> 1. 在实际操作中遍历DFA不应该是到达终结态就停止，而是一直读入字符直到达到不可能终结态，然后回退查找最长的。
> 2. 关于遍历DFA还是NFA，NFA的理由是DFA状态太多，DFA的理由是NFA复杂度不可控。

# 语法分析
识别符号串S是否为某个合法的语法单元。
种类具有：通用语法分析器、自顶向下（从根节点出发）和自底向上（从叶节点出发）。
后两种语法分析器**通常总是从左到右、逐个扫描词法单元**

## 文法
$G=(V_T,V_N,S,P)$，$V_T$表示终结符号集，$V_N$非终结符号符号集,$P$是产生式$\alpha\rightarrow \beta$，$S$是开始符号

### 上下文无关文法
Context-Free Grammar(CFG)
所有产生式的左边只有一个非终结符号，即$A-\rightarrow \beta$

直接推导: $\gamma\alpha\delta \Rightarrow \gamma\beta\delta$，倒过来叫做直接规约。
对于一个直接推导序列$a_0\Rightarrow a_1\Rightarrow\dots\Rightarrow a_n$，叫做$a_0\Rightarrow^+ a_n$，根据和正则表达式类似的方法可以定义$\Rightarrow^*$

#### 语法分析树
句型：$S\Rightarrow^* \alpha$就称$\alpha$是$S$的句型。
句子：不包含非终结符的句型叫做句子。
语言：$L(G)$，文法$G$所有句子的集合。

可以通过推导序列 / 规约序列画出语法分析树。

#### 二义性
1. 一个句子的结构可能不唯一
2. 一个句子的对应的分析树可能不唯一
如果一个文法中存在某个句子有两棵分析树, 那么该句子是二义性的。
如果一个文法存在二义性句子，那么就称这个文法是二义性文法

#### 证明L(G)和L相同
证明文法生成的语言：
1. 首先证明L(G)属于L（按照推导序列长度进行数学归纳）
2. 然后证明L属于L(G) （按照符号串的长度来构造推导序列）

#### 上下文无关文法和正则表达式
上下文无关文法比正则表达式的能力更强。
存在无法用正则表达式表达的上下文无关文法：$\{a^nb^n|n>0\}$，可以通过状态机的状态数证明；但是所有的正则表达式都可以用上下文无关文法表示，等价于NFA的每一个状态都是文法中的一个非终结符。
NFA接受一个句子实际上是文法推导出该句子的过程。
#### 文法分类
- 任意文法（0型）：$\gamma\alpha\delta \rightarrow \gamma\beta\delta$
- 上下文有关文法（1型）：$\gamma A\delta\rightarrow \gamma\beta\delta$
- 上下文无关文法（2型）：$A\rightarrow \beta$
- 正则文法（3型）：
	- （右线性）：$A\rightarrow aB, A\rightarrow a$
	- （左线性）：$A\rightarrow Ba, A\rightarrow a$

### 文法设计
#### 消除二义性
举例：为了保证“else和最近未匹配的then匹配”，在文法中引入"matched_stmt"

#### 消除左递归
**直接左递归**：
$$
\begin{aligned}
A\rightarrow Aa|b
\end{aligned}
$$
可以变成
$$
\begin{aligned}
A\rightarrow bA' \\
A'\rightarrow aA' | \varepsilon \\
\end{aligned}
$$

**间接左递归：** 考虑将生成式带入，然后变成直接左递归再消除。

消除所有左递归的算法：将非终结符按照一定顺序排列，然后对于第$i$个终结符，每个形如$A_i \rightarrow A_jr(j<i)$的规则展开替换，然后消除其中的左递归。
> 不同的顺序可能导致不同的结果，但是他们本质是相同的。