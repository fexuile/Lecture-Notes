## 前言
编译器 VS 解释器：
- 编译器是将源程序转换成可执行程序（先转换后执行）
- 解释器是在转换源程序的同时执行程序（边转换边执行）

编译器的组织结构：前端（从源程序到中间代码），后端（从中间代码到机器指令）
遍（Pass）：对源程序或者中间代码从头到尾扫描一次完成任务，这过程叫做pass。

## 词法分析
词法分析器：读入源程序，输出token序列（包括名字+类型）
token类别包括
- 保留字
- 标识符
- 字面常数
- 运算符
- 分解符

如何识别词法单元：
1. 状态转换图：**优先匹配长度最长的，长度相同的情况下匹配最先的**
2. LEX生成工具：lex源程序->C文件->可执行文件，匹配规则和状态转换图相同。

有限自动机：是识别器，只能对每个可能的输入串简单地回答 yes / no
DFA：确定的有限自动机，对于一个状态的一个输入只有可能有一个输出和后继状态。
NFA：不确定的有限自动机，对于一个状态一个输入应该是转移到状态的一个子集。NFA可以转移$\varepsilon$。
**DFA的表达能力与NFA是等价的，DFA是特殊的NFA**

从正则表达式到NFA：通过一个定式可以得到：
- |就走上下两条
- +就连在一起
- \*就采用一个循环的来表示
然后将正则表达式一一还原即可。

从NFA到DFA：通过子集构造法得到，每一步都走到$\varepsilon$闭包中。

DFA的化简：首先将集合分为终结态和非终结态，然后依次划分出与集合内转移不相同的，直到无法再划分。

Lex的做法：先将NFA合并，然后变成DFA化简，确定终结态。
> 注意：
> 1. 在实际操作中遍历DFA不应该是到达终结态就停止，而是一直读入字符直到达到不可能终结态，然后回退查找最长的。
> 2. 关于遍历DFA还是NFA，NFA的理由是DFA状态太多，DFA的理由是NFA复杂度不可控。

