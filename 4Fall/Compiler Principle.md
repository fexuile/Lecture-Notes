# 前言
编译器 VS 解释器：
- 编译器是将源程序转换成可执行程序（先转换后执行）
- 解释器是在转换源程序的同时执行程序（边转换边执行）

编译器的组织结构：前端（从源程序到中间代码），后端（从中间代码到机器指令）
遍（Pass）：对源程序或者中间代码从头到尾扫描一次完成任务，这过程叫做pass。

# 词法分析
词法分析器：读入源程序，输出token序列（包括名字+类型）
token类别包括
- 保留字
- 标识符
- 字面常数
- 运算符
- 分解符

如何识别词法单元：
1. 状态转换图：**优先匹配长度最长的，长度相同的情况下匹配最先的**
2. LEX生成工具：lex源程序->C文件->可执行文件，匹配规则和状态转换图相同。

有限自动机：是识别器，只能对每个可能的输入串简单地回答 yes / no
DFA：确定的有限自动机，对于一个状态的一个输入只有可能有一个输出和后继状态。
NFA：不确定的有限自动机，对于一个状态一个输入应该是转移到状态的一个子集。NFA可以转移$\varepsilon$。
**DFA的表达能力与NFA是等价的，DFA是特殊的NFA**

从正则表达式到NFA：通过一个定式可以得到：
- |就走上下两条
- +就连在一起
- \*就采用一个循环的来表示
然后将正则表达式一一还原即可。

从NFA到DFA：通过子集构造法得到，每一步都走到$\varepsilon$闭包中。

DFA的化简：首先将集合分为终结态和非终结态，然后依次划分出与集合内转移不相同的，直到无法再划分。

Lex的做法：先将NFA合并，然后变成DFA化简，确定终结态。
> 注意：
> 1. 在实际操作中遍历DFA不应该是到达终结态就停止，而是一直读入字符直到达到不可能终结态，然后回退查找最长的。
> 2. 关于遍历DFA还是NFA，NFA的理由是DFA状态太多，DFA的理由是NFA复杂度不可控。

# 语法分析
识别符号串S是否为某个合法的语法单元。
种类具有：通用语法分析器、自顶向下（从根节点出发）和自底向上（从叶节点出发）。
后两种语法分析器**通常总是从左到右、逐个扫描词法单元**

## 文法
$G=(V_T,V_N,S,P)$，$V_T$表示终结符号集，$V_N$非终结符号符号集,$P$是产生式$\alpha\rightarrow \beta$，$S$是开始符号

### 上下文无关文法
Context-Free Grammar(CFG)
所有产生式的左边只有一个非终结符号，即$A-\rightarrow \beta$

直接推导: $\gamma\alpha\delta \Rightarrow \gamma\beta\delta$，倒过来叫做直接规约。
对于一个直接推导序列$a_0\Rightarrow a_1\Rightarrow\dots\Rightarrow a_n$，叫做$a_0\Rightarrow^+ a_n$，根据和正则表达式类似的方法可以定义$\Rightarrow^*$

### 语法分析树
句型：$S\Rightarrow^* \alpha$就称$\alpha$是$S$的句型。
句子：不包含非终结符的句型叫做句子。
语言：$L(G)$，文法$G$所有句子的集合。

可以通过推导序列 / 规约序列画出语法分析树。

### 二义性
1. 一个句子的结构可能不唯一
2. 一个句子的对应的分析树可能不唯一
如果一个文法中存在某个句子有两棵分析树, 那么该句子是二义性的。
如果一个文法存在二义性句子，那么就称这个文法是二义性文法

### 其他
证明文法生成的语言：
1. 首先证明L(G)属于L（按照推导序列长度进行数学归纳）
2. 然后证明L属于L(G) （按照符号串的长度来构造推导序列）


